package Linux::Info::DiskStats;
use strict;
use warnings;
use Carp qw(croak);
use Time::HiRes 1.9725;
use YAML::XS 0.41;

# VERSION

=head1 NAME

Linux::Info::DiskStats - Collect linux disk statistics.

=head1 SYNOPSIS

    use Linux::Info::DiskStats;

    my $lxs = Linux::Info::DiskStats->new;
    $lxs->init;
    sleep 1;
    my $stat = $lxs->get;

Or

    my $lxs = Linux::Info::DiskStats->new(initfile => $file);
    $lxs->init;
    my $stat = $lxs->get;

=head1 DESCRIPTION

Linux::Info::DiskStats gathers disk statistics from the virtual F</proc> filesystem (procfs).

For more information read the documentation of the front-end module L<Linux::Info>.

=head1 DISK STATISTICS

Generated by F</proc/diskstats> or F</proc/partitions>.

    major   -  The mayor number of the disk
    minor   -  The minor number of the disk
    rdreq   -  Number of read requests that were made to physical disk per second.
    rdbyt   -  Number of bytes that were read from physical disk per second.
    wrtreq  -  Number of write requests that were made to physical disk per second.
    wrtbyt  -  Number of bytes that were written to physical disk per second.
    ttreq   -  Total number of requests were made from/to physical disk per second.
    ttbyt   -  Total number of bytes transmitted from/to physical disk per second.

=head1 METHODS

=head2 new()

Call C<new()> to create a new object.

    my $lxs = Linux::Info::DiskStats->new;

Maybe you want to store/load the initial statistics to/from a file:

    my $lxs = Linux::Info::DiskStats->new(initfile => '/tmp/diskstats.yml');

If you set C<initfile> it's not necessary to call sleep before C<get()>.

It's also possible to set the path to the proc filesystem.

     Linux::Info::DiskStats->new(
        files => {
            # This is the default
            path       => '/proc',
            diskstats  => 'diskstats',
            partitions => 'partitions',
        }
    );

=head2 init()

Call C<init()> to initialize the statistics.

    $lxs->init;

=head2 get()

Call C<get()> to get the statistics. C<get()> returns the statistics as a hash reference.

    my $stat = $lxs->get;

=head2 raw()

Get raw values.

=head1 EXPORTS

Nothing.

=head1 SEE ALSO

=over

=item *

B<proc(5)>

=item *

L<Linux::Info>

=back

=head1 AUTHOR

Alceu Rodrigues de Freitas Junior, E<lt>glasswalk3r@yahoo.com.brE<gt>

=head1 COPYRIGHT AND LICENSE

This software is copyright (c) 2015 of Alceu Rodrigues de Freitas Junior, E<lt>glasswalk3r@yahoo.com.brE<gt>

This file is part of Linux Info project.

Linux-Info is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Linux-Info is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Linux Info.  If not, see <http://www.gnu.org/licenses/>.

use strict;
use warnings;

# Specify the block device file
my $block_device = '/dev/sda1'; # Replace with the appropriate block device

# Open the block device file in binary mode for reading
open my $fh, '<:raw', $block_device or die "Unable to open $block_device: $!";

# Seek to the offset of the superblock (1024 bytes for ext2/ext3/ext4 file systems)
my $superblock_offset = 1024;
seek($fh, $superblock_offset, 0) or die "Unable to seek: $!";

# Read the superblock (usually 1024 bytes)
my $superblock_size = 1024;
my $superblock_data;
read($fh, $superblock_data, $superblock_size) == $superblock_size or die "Unable to read superblock: $!";

# Close the file handle
close $fh;

# Print the hexadecimal representation of the superblock data
my @hex_bytes = unpack("H*", $superblock_data);
print "Superblock Data:\n";
print join(' ', @hex_bytes), "\n";

=cut

sub new {
    my $class = shift;
    my $opts  = ref( $_[0] ) ? shift : {@_};

    my %self = (
        files => {
            path       => '/proc',
            diskstats  => 'diskstats',
            partitions => 'partitions',
        },

        # TODO: must be defined be reading the superblock of each volume
        blocksize => 512,
        fields    => 0,
    );

    if ( defined $opts->{initfile} ) {
        $self{initfile} = $opts->{initfile};
    }

    foreach my $file ( keys %{ $opts->{files} } ) {
        $self{files}{$file} = $opts->{files}->{$file};
    }

    if ( $opts->{blocksize} ) {
        $self{blocksize} = $opts->{blocksize};
    }

    return bless \%self, $class;
}

sub init {
    my $self = shift;

    # TODO: properly test for not finding the file
    if ( $self->{initfile} && -r $self->{initfile} ) {
        $self->{init} = YAML::XS::LoadFile( $self->{initfile} );
        $self->{time} = delete $self->{init}->{time};
    }
    else {
        $self->{time} = Time::HiRes::gettimeofday();
        $self->{init} = $self->_load;
    }

    return 1;
}

sub get {
    my $self  = shift;
    my $class = ref $self;

    if ( !exists $self->{init} ) {
        croak "$class: there are no initial statistics defined";
    }

    $self->{stats} = $self->_load;
    $self->_deltas;

    if ( $self->{initfile} ) {
        $self->{init}->{time} = $self->{time};
        YAML::XS::DumpFile( $self->{initfile}, $self->{init} );
    }

    return $self->{stats};
}

sub raw {
    my $self = shift;
    my $raw  = $self->_load;

    return $raw;
}

#
# private stuff
#

sub _load {
    my $self  = shift;
    my $class = ref $self;
    my $file  = $self->{files};
    my $bksz  = $self->{blocksize};
    my ( %stats, $fh );

    # TODO: create better names for the stats
    # TODO: create alias for the names of the stats to be backwards compatible
    # TODO: warn about deprecation

# 2.4 series
# In the Linux kernel version 2.4, the /proc/diskstats file provides statistics for block devices (disks) in the system. The format of this
# file is as follows:
# 1 - major number
# 2 - minor mumber
# 3 - device name
# 4 - reads completed successfully
# 5 - reads merged
# 6 - sectors read
# 7 - time spent reading (ms)
# 8 - writes completed
# 9 - writes merged
# 10 - sectors written
# 11 - time spent writing (ms)
# 12 - I/Os currently in progress
# 13 - time spent doing I/Os (ms)
# 14 - weighted time spent doing I/Os (ms)
#
# Each line corresponds to a single block device, and the values are space-separated. Here's what each field represents:
#
# Major number: The major number of the device.
# Minor number: The minor number of the device.
# Device name: The device name.
# Reads completed successfully: The number of reads completed successfully.
# Reads merged: The number of reads merged (since Linux 2.6.22).
# Sectors read: The number of sectors read.
# Time spent reading (ms): The total time spent reading (in milliseconds).
# Writes completed: The number of writes completed successfully.
# Writes merged: The number of writes merged (since Linux 2.6.22).
# Sectors written: The number of sectors written.
# Time spent writing (ms): The total time spent writing (in milliseconds).
# I/Os currently in progress: The number of I/Os currently in progress.
# Time spent doing I/Os (ms): The total time spent doing I/Os (in milliseconds).
# Weighted time spent doing I/Os (ms): The total weighted time spent doing I/Os (in milliseconds).

# 2.6 series
# 1 - major number
# 2 - minor number
# 3 - device name
# 4 - reads completed successfully
# 5 - reads merged
# 6 - sectors read
# 7 - time spent reading (ms)
# 8 - writes completed successfully
# 9 - writes merged
# 10 - sectors written
# 11 - time spent writing (ms)
# 12 - I/Os currently in progress
# 13 - time spent doing I/Os (ms)
# 14 - weighted time spent doing I/Os (ms)
# 15 - discards completed successfully (since Linux 2.6.18)
# 16 - discards merged (since Linux 2.6.18)
# 17 - sectors discarded (since Linux 2.6.18)
# 18 - time spent discarding (ms) (since Linux 2.6.18)
# The fields from 1 to 14 remain the same as in the version 2.4 format, representing various disk I/O statistics. Starting from Linux kernel
# version 2.6.18, additional fields were added to include discard (TRIM) statistics:
# Discards completed successfully: The number of discards completed successfully.
# Discards merged: The number of discards merged (since Linux 2.6.18).
# Sectors discarded: The number of sectors discarded (since Linux 2.6.18).
# Time spent discarding (ms): The total time spent discarding (in milliseconds) (since Linux 2.6.18).
#
# These additional fields provide information about discard operations, which are relevant for SSDs and other storage devices that support the
# TRIM command for improving performance and longevity.

    # one of the both must be opened for the disk statistics!
    # if diskstats (2.6) doesn't exists then let's try to read
    # the partitions (2.4)

    my $file_diskstats =
      $file->{path} ? "$file->{path}/$file->{diskstats}" : $file->{diskstats};
    my $file_partitions =
      $file->{path} ? "$file->{path}/$file->{partitions}" : $file->{partitions};

    my $available_fields = 0;
    my $spaces_regex     = qr/\s+/;

    if ( open $fh, '<', $file_diskstats ) {
        while ( my $line = <$fh> ) {
            chomp $line;
            $available_fields = scalar( split( $spaces_regex, $line ) );

            if (    ( $self->{fields} > 0 )
                and ( $self->{fields} != $available_fields ) )
            {
                warn 'Inconsistent number of fields, had '
                  . $self->{fields}
                  . ", now have $available_fields";
            }

            $self->{fields} = $available_fields;

#                   --      --      --      F1     F2     F3     F4     F5     F6     F7     F8    F9    F10   F11
#                   $1      $2      $3      $4     --     $5     --     $6     --     $7     --    --    --    --
            if ( $line =~
/^\s+(\d+)\s+(\d+)\s+(.+?)\s+(\d+)\s+\d+\s+(\d+)\s+\d+\s+(\d+)\s+\d+\s+(\d+)\s+\d+\s+\d+\s+\d+\s+\d+$/
              )
            {
                for my $x ( $stats{$3} ) {    # $3 -> the device name
                    $x->{major}  = $1;
                    $x->{minor}  = $2;
                    $x->{rdreq}  = $4;            # Field 1
                    $x->{rdbyt}  = $5 * $bksz;    # Field 3
                    $x->{wrtreq} = $6;            # Field 5
                    $x->{wrtbyt} = $7 * $bksz;    # Field 7
                    $x->{ttreq} += $x->{rdreq} + $x->{wrtreq};
                    $x->{ttbyt} += $x->{rdbyt} + $x->{wrtbyt};
                }
            }

 # -----------------------------------------------------------------------------
 # Field  1 -- # of reads issued
 #     This is the total number of reads issued to this partition.
 # Field  2 -- # of sectors read
 #     This is the total number of sectors requested to be read from this
 #     partition.
 # Field  3 -- # of writes issued
 #     This is the total number of writes issued to this partition.
 # Field  4 -- # of sectors written
 #     This is the total number of sectors requested to be written to
 #     this partition.
 # -----------------------------------------------------------------------------
 #                      --      --      --      F1      F2      F3      F4
 #                      $1      $2      $3      $4      $5      $6      $7
            elsif ( $line =~
                /^\s+(\d+)\s+(\d+)\s+(.+?)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)$/ )
            {
                for my $x ( $stats{$3} ) {    # $3 -> the device name
                    $x->{major}  = $1;
                    $x->{minor}  = $2;
                    $x->{rdreq}  = $4;            # Field 1
                    $x->{rdbyt}  = $5 * $bksz;    # Field 2
                    $x->{wrtreq} = $6;            # Field 3
                    $x->{wrtbyt} = $7 * $bksz;    # Field 4
                    $x->{ttreq} += $x->{rdreq} + $x->{wrtreq};
                    $x->{ttbyt} += $x->{rdbyt} + $x->{wrtbyt};
                }
            }
        }
        close($fh);
    }
    elsif ( open $fh, '<', $file_partitions ) {
        while ( my $line = <$fh> ) {

#                           --      --     --     --      F1     F2     F3     F4     F5     F6     F7     F8    F9    F10   F11
#                           $1      $2     --     $3      $4     --     $5     --     $6     --     $7     --    --    --    --
            next
              unless $line =~
/^\s+(\d+)\s+(\d+)\s+\d+\s+(.+?)\s+(\d+)\s+\d+\s+(\d+)\s+\d+\s+(\d+)\s+\d+\s+(\d+)\s+\d+\s+\d+\s+\d+\s+\d+$/;
            for my $x ( $stats{$3} ) {    # $3 -> the device name
                $x->{major}  = $1;
                $x->{minor}  = $2;
                $x->{rdreq}  = $4;            # Field 1
                $x->{rdbyt}  = $5 * $bksz;    # Field 3
                $x->{wrtreq} = $6;            # Field 5
                $x->{wrtbyt} = $7 * $bksz;    # Field 7
                $x->{ttreq} += $x->{rdreq} + $x->{wrtreq};
                $x->{ttbyt} += $x->{rdbyt} + $x->{wrtbyt};
            }
        }
        close($fh);
    }
    else {
        croak "$class: unable to open $file_diskstats or $file_partitions ($!)";
    }

    if ( !-e $file_diskstats || !scalar %stats ) {
        croak
"$class: no diskstats found! your system seems not to be compiled with CONFIG_BLK_STATS=y";
    }

    return \%stats;
}

sub _deltas {
    my $self  = shift;
    my $class = ref $self;
    my $istat = $self->{init};
    my $lstat = $self->{stats};
    my $time  = Time::HiRes::gettimeofday();
    my $delta = sprintf( '%.2f', $time - $self->{time} );
    $self->{time} = $time;

    foreach my $dev ( keys %{$lstat} ) {
        if ( !exists $istat->{$dev} ) {
            delete $lstat->{$dev};
            next;
        }

        my $idev = $istat->{$dev};
        my $ldev = $lstat->{$dev};

        while ( my ( $k, $v ) = each %{$ldev} ) {
            next if $k =~ /^major\z|^minor\z/;

            if ( !defined $idev->{$k} ) {
                croak "$class: not defined key found '$k'";
            }

            if ( $v !~ /^\d+\z/ || $ldev->{$k} !~ /^\d+\z/ ) {
                croak "$class: invalid value for key '$k'";
            }

            if ( $ldev->{$k} == $idev->{$k} || $idev->{$k} > $ldev->{$k} ) {
                $ldev->{$k} = sprintf( '%.2f', 0 );
            }
            elsif ( $delta > 0 ) {
                $ldev->{$k} =
                  sprintf( '%.2f', ( $ldev->{$k} - $idev->{$k} ) / $delta );
            }
            else {
                $ldev->{$k} = sprintf( '%.2f', $ldev->{$k} - $idev->{$k} );
            }

            $idev->{$k} = $v;
        }
    }
}

sub fields_read() {
    my $self = shift;
    return $self->{fields};
}

1;
